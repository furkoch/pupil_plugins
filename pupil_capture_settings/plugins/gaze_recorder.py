
import os, errno
import sys
sys.path.append('F:\\Projects\\repo\\sensorics\\EyeTracker\\pupil\\pupil_src\\shared_modules')
sys.path.append('C:\\Users\\drivesense\\pupil_capture_settings\\pupil_app')
sys.path.append('C:\\Users\\drivesense\\AppData\\Local\\Programs\\Python\\Python36\\Lib\\site-packages')
sys.path.append('C:\\Users\\drivesense\\AppData\\Roaming\\Python\\Python36\\site-packages')
import csv_utils
import time
from pyglui import ui
import numpy as np
from plugin import Plugin
from time import strftime, localtime, time, gmtime
from shutil import copy2
from file_methods import save_object, load_object
from methods import get_system_info
from av_writer import JPEG_Writer, AV_Writer, Audio_Capture
from ndsi import H264Writer
from calibration_routines.camera_intrinsics_estimation import load_camera_calibration
import logging
logger = logging.getLogger(__name__)
import json
#from remote.ws_event_server import WSEventServer
import _thread
from remote.udp_socket import UDP_Socket
import threading
from remote.websocket_client import WSClient


def get_auto_name():
    return strftime("%Y_%m_%d", localtime())

class Gaze_Recorder(Plugin):
    """Capture Recorder"""
    def __init__(self, g_pool, session_name=get_auto_name(), rec_dir=None,
                 user_info={'name': '', 'additional_field': 'change_me'},
                 info_menu_conf={}, show_info_menu=False, record_eye=False,
                 raw_jpeg=True):
        super().__init__(g_pool)
        # update name if it was autogenerated.
        if session_name.startswith('20') and len(session_name) == 10:
            session_name = get_auto_name()

        base_dir = self.g_pool.user_dir.rsplit(os.path.sep, 1)[0]
        default_rec_dir = os.path.join(base_dir, 'recordings')

        if rec_dir and rec_dir != default_rec_dir and self.verify_path(rec_dir):
            self.rec_dir = rec_dir
        else:
            try:
                os.makedirs(default_rec_dir)
            except OSError as e:
                if e.errno != errno.EEXIST:
                    logger.error("Could not create Rec dir")
                    raise e
            else:
                logger.info('Created standard Rec dir at "{}"'.format(default_rec_dir))
            self.rec_dir = default_rec_dir

        self.raw_jpeg = raw_jpeg
        self.order = .9
        self.record_eye = record_eye
        self.session_name = session_name
        self.running = False
        self.menu = None
        self.button = None

        self.user_info = user_info
        self.show_info_menu = show_info_menu
        self.info_menu = None
        self.info_menu_conf = info_menu_conf

        self.socket = None
        self.udp_socket = None

        thread = threading.Thread(target=self.run_ws, args=())
        thread.daemon = True  # Daemonize thread
        thread.start()

        #run udp-client
        self.udp_socket = UDP_Socket(host="127.0.0.1", port=2010)

        self.rec_path = None

        self.running = False
        self.menu_toggle = None
        self.quickbar_toggle = None

        self.smooth_x = 0.5
        self.smooth_y = 0.5


    def run_ws(self):
        try:
            socket = WSClient('ws://localhost:3434/', self)  # url, onOpen,onClose, onReceive)
            socket.connect()
            socket.run_forever()
        except:
            print("Exception Occured")


    def on_open(self, ws):
        print("On open Called")
        ws.send(json.dumps({"event": "registerForUpdates", "value": "ON_REC_PATH_CREATED"}))
        ws.send(json.dumps({"event": "registerForUpdates", "value": "ON_EYETRACKING_ENDED"}))

    def on_message_received(self,ws, message):
        logger.info("Yo-yo, message is received {}".format(message))
        json_message = json.loads(str(message))

        event_name = json_message['event']
        event_value = json_message['value']

        if event_name == "ON_REC_PATH_CREATED":
            self.rec_path = event_value
            self.notify_all({'subject': 'recording.must_start', 'session_name': self.session_name})
            self.notify_all({'subject': 'recording.must_start', 'session_name': self.session_name, 'remote_notify': 'all'})
            #For OpenDS
            ws.send(json.dumps({"event": "ON_EYETRACKING_STARTED", "value": "STARTED"}))

        if event_name == "ON_EYETRACKING_ENDED":
            self.notify_all({'subject': 'recording.must_stop'})
            self.notify_all({'subject': 'recording.must_stop', 'remote_notify': 'all'})
            ws.send(json.dumps({"event": "ON_EYETRACKING_ENDED_AND_SAVED", "value": "ENDED_SAVED"}))

    def on_close(self,ws, code, reason=None):
        logger.info("He-he, the websocket is closed, code: {}, reason: {}".format(code,reason))


    def send_udp_data(self, x,y,ts):
        self.udp_socket.send_message(str((x, y, ts)))

    def get_init_dict(self):
        d = {}
        d['record_eye'] = self.record_eye
        d['session_name'] = self.session_name
        d['user_info'] = self.user_info
        d['info_menu_conf'] = self.info_menu_conf
        d['show_info_menu'] = self.show_info_menu
        d['rec_dir'] = self.rec_dir
        d['raw_jpeg'] = self.raw_jpeg
        return d

    def init_gui(self):
        self.menu = ui.Growing_Menu('Gaze Recorder')
        self.menu.collapsed = True

        # Check udp-connection
        self.text_udp_status = None
        if self.udp_socket is None or self.udp_socket.is_connected() == False:
            self.text_udp_status = ui.Info_Text('UDP Status: Not connected')
        else:
            self.text_udp_status = ui.Info_Text('UDP Status: Connected')
        self.menu.append(self.text_udp_status)


        #self.button = ui.Thumb('running', self, setter=self.toggle, label='REC', hotkey='q')
        self.button = ui.Thumb('running', self, setter=self.toggle, label=chr(0xf03d), label_font='fontawesome', label_offset_size=-30, hotkey='e')
        self.button.on_color[:] = (1, .0, .0, .8)
        #self.menu.append(self.button)
        self.g_pool.quickbar.insert(1, self.button)

        # self.button = ui.Thumb('running', self, setter=self.toggle, label='RC', hotkey='r')
        # self.button.on_color[:] = (1, .0, .0, .8)
        # self.g_pool.quickbar.insert(1, self.button)

        recording_menu = ui.Growing_Menu('Recording Settings')
        recording_menu.collapsed = True
        recording_menu.append(ui.Text_Input('rec_dir', self, setter=self.set_rec_dir, label='Path to recordings'))
        recording_menu.append(ui.Text_Input('session_name', self, setter=self.set_session_name, label='Recording session name'))

        self.menu.append(recording_menu)
        self.g_pool.sidebar.insert(3, self.menu)


    def deinit_gui(self):
        if self.menu:
            self.g_pool.sidebar.remove(self.menu)
            self.menu = None
        if self.button:
            self.g_pool.quickbar.remove(self.button)
            self.button = None

    def toggle(self, _=None):
        if self.running:
            self.notify_all({'subject': 'recording.must_stop'})
            self.notify_all({'subject': 'recording.must_stop', 'remote_notify': 'all'})
        else:
            self.notify_all({'subject': 'recording.must_start', 'session_name': self.session_name})
            self.notify_all({'subject': 'recording.must_start', 'session_name': self.session_name, 'remote_notify': 'all'})

    def on_notify(self, notification):
        """Handles recorder notifications
        Reacts to notifications:
            ``recording.should_start``: Starts a new recording session.
                fields: 'session_name' change session name
                    use `/` to att dirs.
                    start with `/` to ingore the rec base dir and start from root instead.
            ``recording.should_stop``: Stops current recording session
        Emits notifications:
            ``recording.started``: New recording session started
            ``recording.stopped``: Current recording session stopped
        Args:
            notification (dictionary): Notification dictionary
        """
        # notification wants to be recorded
        if notification.get('record', False) and self.running:
            if 'timestamp' not in notification:
                logger.error("Notification without timestamp will not be saved.")
            else:
                self.data['notifications'].append(notification)
        elif notification['subject'] == 'recording.must_start':
            if self.running:
                logger.info('Recording already running!')
            elif not self.g_pool.capture.online:
                logger.error("Current world capture is offline. Please reconnect or switch to fake capture")
            else:
                if notification.get("session_name", ""):
                    self.set_session_name(notification["session_name"])
                self.start()

        elif notification['subject'] == 'recording.must_stop':
            if self.running:
                self.stop()
            else:
                logger.info('Recording already stopped!')

    def get_rec_time_str(self):
        rec_time = gmtime(time()-self.start_time)
        return strftime("%H:%M:%S", rec_time)

    def start(self):
        self.data = {'pupil_positions': [], 'gaze_positions': [], 'notifications': []}
        self.frame_count = 0
        self.running = True
        self.menu.read_only = True
        self.start_time = time()

        session = os.path.join(self.rec_dir, self.session_name)
        try:
            os.makedirs(session)
            logger.debug("Created new recordings session dir {}".format(session))

        except:
            logger.debug("Recordings session dir {} already exists, using it.".format(session))

        if self.rec_path is None:
            # set up self incrementing folder within session folder
            counter = 0
            while True:
                self.rec_path = os.path.join(session, "{:03d}/".format(counter))
                try:
                    os.mkdir(self.rec_path)
                    logger.debug("Created new recording dir {}".format(self.rec_path))
                    break
                except:
                    logger.debug(
                        "We dont want to overwrite data, incrementing counter & trying to make new data folder")
                    counter += 1

        self.meta_info_path = os.path.join(self.rec_path, "info.csv")

        with open(self.meta_info_path, 'w', newline='') as csvfile:
            csv_utils.write_key_value_file(csvfile, {
                'Recording Name': self.session_name,
                'Start Date': strftime("%d.%m.%Y", localtime(self.start_time)),
                'Start Time': strftime("%H:%M:%S", localtime(self.start_time))
            })

        self.video_path = os.path.join(self.rec_path, "world.mp4")
        if self.raw_jpeg and self.g_pool.capture.jpeg_support:
            self.writer = JPEG_Writer(self.video_path, self.g_pool.capture.frame_rate)
        elif hasattr(self.g_pool.capture._recent_frame, 'h264_buffer'):
            self.writer = H264Writer(self.video_path,
                                     self.g_pool.capture.frame_size[0],
                                     self.g_pool.capture.frame_size[1],
                                     int(self.g_pool.capture.frame_rate))
        else:
            self.writer = AV_Writer(self.video_path, fps=self.g_pool.capture.frame_rate)

        try:
            cal_pt_path = os.path.join(self.g_pool.user_dir, "user_calibration_data")
            cal_data = load_object(cal_pt_path)
            notification = {'subject': 'calibration.calibration_data', 'record': True}
            notification.update(cal_data)
            self.data['notifications'].append(notification)
        except:
            pass

        if self.show_info_menu:
            self.open_info_menu()
        logger.info("Started Recording.")
        self.notify_all({'subject': 'recording.started', 'rec_path': self.rec_path,
                         'session_name': self.session_name, 'record_eye': self.record_eye,
                         'compression': self.raw_jpeg})

    def open_info_menu(self):
        self.info_menu = ui.Growing_Menu('additional Recording Info', size=(300, 300), pos=(300, 300))
        self.info_menu.configuration = self.info_menu_conf

        def populate_info_menu():
            self.info_menu.elements[:-2] = []
            for name in self.user_info.keys():
                self.info_menu.insert(0, ui.Text_Input(name, self.user_info))

        def set_user_info(new_string):
            self.user_info = new_string
            populate_info_menu()

        populate_info_menu()
        self.info_menu.append(ui.Info_Text('Use the *user info* field to add/remove additional fields and their values. The format must be a valid Python dictionary. For example -- {"key":"value"}. You can add as many fields as you require. Your custom fields will be saved for your next session.'))
        self.info_menu.append(ui.Text_Input('user_info', self, setter=set_user_info, label="User info"))
        self.g_pool.gui.append(self.info_menu)

    def close_info_menu(self):
        if self.info_menu:
            self.info_menu_conf = self.info_menu.configuration
            self.g_pool.gui.remove(self.info_menu)
            self.info_menu = None

    def extract_gazes(self,gaze_on_screen):
            raw_x, raw_y = self.smoother.normalize_gaze_by_length(gaze_on_screen)

            self.smooth_x += 0.35 * (raw_x - self.smooth_x)
            self.smooth_y += 0.35 * (raw_y - self.smooth_y)

            x = self.smooth_x
            y = self.smooth_y

            y = 1 - y  # inverting y so it shows up correctly on screen

            x = round(min(1, max(0, x)), 2)
            y = round(min(1, max(0, y)), 2)

            return x,y

    def smooth_gaze(self,raw_x,raw_y):
        self.smooth_x += 0.35 * (raw_x - self.smooth_x)
        self.smooth_y += 0.35 * (raw_y - self.smooth_y)

        x = self.smooth_x
        y = self.smooth_y

        y = 1 - y  # inverting y so it shows up correctly on screen

        x = round(min(1, max(0, x)), 2)
        y = round(min(1, max(0, y)), 2)

        return x,y

    def srf_tracked(self, events):
        srf_gazes = events.get('surfaces', [])
        if not srf_gazes:
            return None
        return srf_gazes[0]['name']

        #     if srf['name'] == "screen":
        #         fr_gazes = self.gaze_extractor.process_gaze_from_screen(srf['gaze_on_srf'])
        #         for pnt in srf['gaze_on_srf']:
        #             logger.warning(pnt['base_data']['norm_pos'])
        #         break
        #
        # return srf_gazes

    def smooth_data(self,gazes_on_screen, gazeLen):

        raw_x = raw_y = 0

        for gaze in gazes_on_screen:
            raw_x+=gaze['norm_pos'][0]
            raw_y+=gaze['norm_pos'][1]

        raw_x /= gazeLen
        raw_y /= gazeLen

        self.smooth_x += 0.35 * (raw_x - self.smooth_x)
        self.smooth_y += 0.35 * (raw_y - self.smooth_y)

        x = self.smooth_x
        y = self.smooth_y

        y = 1 - y

        # inverting y so it shows up correctly on screen
        x = round(min(1, max(0, x)), 2)
        y = round(min(1, max(0, y)), 2)

        # x *= int(self.x_dim)
        # y *= int(self.y_dim)
        return str((x, y, 1.0))

    def recent_events(self, events):
        # string = self.socket.recv()
        # topic, messagedata = string.split()
        # if topic == 10001:
        #     logger.info("{} {}".format(topic, messagedata))

        if self.running:
            srf_gazes = events.get('surfaces', [])

            for srf in srf_gazes:
                if srf['name'] == "screen" or srf['name'] == "wheel":
                    gazes_on_screen = srf['gaze_on_srf']
                    gazeLen = len(gazes_on_screen)

                    if gazeLen > 0:
                       #recent_gaze = gaze_on_screen[0]
                       raw_x = raw_y = 0
                       timestamps = []

                       # for gaze in gazes_on_screen:
                       #     raw_x += gaze['norm_pos'][0]
                       #     raw_y += gaze['norm_pos'][1]
                       #     #logger.info(gaze)
                       #     timestamp = gaze['base_data']['timestamp']
                       #     timestamps.append(timestamp)
                       #
                       #
                       # raw_x /= gazeLen
                       # raw_y /= gazeLen

                       raw_x = gazes_on_screen[0]['norm_pos'][0]
                       raw_y = gazes_on_screen[0]['norm_pos'][1]

                       self.smooth_x += 0.35 * (raw_x - self.smooth_x)
                       self.smooth_y += 0.35 * (raw_y - self.smooth_y)

                       x = self.smooth_x
                       y = 1 - self.smooth_y

                       gaze_positions = []
                       x = round(min(1, max(0, x)), 2) * 1.0
                       y = round(min(1, max(0, y)), 2) * 1.0
                       gaze_positions.append(x)
                       gaze_positions.append(y)

                       jsonObj = json.dumps({"srf": srf['name'], "gaze_positions":gaze_positions,"timestamps":timestamps})
                       self.udp_socket.send_message(jsonObj)


                       #print(jsonObj)


            for key, data in events.items():

                if key not in ('dt', 'frame', 'audio_packets'):
                    try:
                        self.data[key] += data
                    except KeyError:
                        self.data[key] = []
                        self.data[key] += data

            if 'frame' in events:
                frame = events['frame']
                self.writer.write_video_frame(frame)
                self.frame_count += 1

            # # cv2.putText(frame.img, "Frame %s"%self.frame_count,(200,200), cv2.FONT_HERSHEY_SIMPLEX,1,(255,100,100))

            self.button.status_text = self.get_rec_time_str()

    def stop(self):
        # explicit release of VideoWriter
        self.writer.release()
        self.writer = None

        save_object(self.data, os.path.join(self.rec_path, "pupil_data"))

        try:
            copy2(os.path.join(self.g_pool.user_dir, "surface_definitions"),
                  os.path.join(self.rec_path, "surface_definitions"))
        except:
            logger.info("No surface_definitions data found. You may want this if you do marker tracking.")

        camera_calibration = load_camera_calibration(self.g_pool)
        if camera_calibration is not None:
            save_object(camera_calibration, os.path.join(self.rec_path, "camera_calibration"))
        else:
            logger.info("No camera calibration found.")

        try:
            with open(self.meta_info_path, 'a', newline='') as csvfile:
                csv_utils.write_key_value_file(csvfile, {
                    'Duration Time': self.get_rec_time_str(),
                    'World Camera Frames': self.frame_count,
                    'World Camera Resolution': str(self.g_pool.capture.frame_size[0])+"x"+str(self.g_pool.capture.frame_size[1]),
                    'Capture Software Version': self.g_pool.version,
                    'Data Format Version': self.g_pool.version,
                    'System Info': get_system_info()
                }, append=True)
        except Exception:
            logger.exception("Could not save metadata. Please report this bug!")

        try:
            with open(os.path.join(self.rec_path, "user_info.csv"), 'w', newline='') as csvfile:
                csv_utils.write_key_value_file(csvfile, self.user_info)
        except Exception:
            logger.exception("Could not save userdata. Please report this bug!")

        self.close_info_menu()

        self.running = False
        self.menu.read_only = False
        self.button.status_text = ''

        self.data = {'pupil_positions': [], 'gaze_positions': []}
        self.pupil_pos_list = []
        self.gaze_pos_list = []

        logger.info("Saved Recording.")
        self.notify_all({'subject': 'recording.stopped', 'rec_path': self.rec_path})


    def cleanup(self):
        """gets called when the plugin get terminated.
           either volunatily or forced.
        """
        if self.running:
            self.stop()
        self.deinit_gui()

    def verify_path(self, val):
        try:
            n_path = os.path.expanduser(val)
            logger.debug("Expanded user path.")
        except:
            n_path = val
        if not n_path:
            logger.warning("Please specify a path.")
            return False
        elif not os.path.isdir(n_path):
            logger.warning("This is not a valid path.")
            return False
        # elif not os.access(n_path, os.W_OK):
        elif not writable_dir(n_path):
            logger.warning("Do not have write access to '{}'.".format(n_path))
            return False
        else:
            return n_path

    def set_rec_dir(self, val):
        n_path = self.verify_path(val)
        if n_path:
            self.rec_dir = n_path

    def set_session_name(self, val):
        if not val:
            self.session_name = get_auto_name()
        else:
            if os.path.sep in val:
                logger.warning('You session name will create one or more subdirectories')
            self.session_name = val

    def old_method(self):
        pass
        # key = "gaze_positions"
        # srf = self.srf_tracked(events)
        # jsonObj = json.dumps({"srf": srf, "data": events[key]})
        # self.udp_socket.send_message(jsonObj)

        # if self.running:
        #
        #     srf_gazes = events.get('surfaces', [])
        #     for srf in srf_gazes:
        # logger.warning(srf['name'] )
        # if srf['name'] == "screen":
        #     gaze_on_screen = srf['gaze_on_srf']
        #     gazeLen = len(gaze_on_screen)
        #     if gazeLen > 0:
        #         # recent_gaze = gaze_on_screen[0]
        #         gaze_str = self.smooth_data(gaze_on_screen, gazeLen)
        #         self.udp_socket.send_message(gaze_str)
        #
        #         # fr_gazes = self.frequent_gazes
        #         # self.frequent_gazes = []
        #
        #         logger.info(gaze_str)

        # for pnt in srf['gaze_on_srf']:
        #     norm_x = pnt['base_data']['norm_pos'][0]
        #     norm_y = pnt['base_data']['norm_pos'][1]
        #     # norm_pos = pnt['base_data']['norm_pos']
        #     # norm_pos_x = norm_pos[0]
        #     # norm_pos_y = ['base_data'][1]
        #     logger.warning(str((norm_x, norm_y, 1.0)))
        #     self.udp_socket.send_message(str((norm_x, norm_y, 1.0)))
        #     break

        # fr_gazes = self.frequent_gazes
        # self.frequent_gazes = []

def writable_dir(n_path):
    try:
        open(os.path.join(n_path, 'dummpy_tmp'), 'w')
    except IOError:
        return False
    else:
        os.remove(os.path.join(n_path, 'dummpy_tmp'))
        return True